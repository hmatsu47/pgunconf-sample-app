create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,

  primary key (id),
  unique (username),
  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update their own profile."
  on profiles for update
  using ( auth.uid() = id );

-- リアルタイムをセットアップ
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- ストレージをセットアップ
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );

-- 追加のテーブルをセットアップ
create table articles (
  id bigint generated by default as identity,
  updated_at timestamp with time zone,
  title text not null,
  note text,
  note_type int not null default 1,
  userid uuid not null,

  primary key (id),
  constraint title_length check (char_length(title) > 0)
);

alter table articles enable row level security;

create policy "Users can view their own articles or disclosed articles."
  on articles for select
  using ( ( auth.uid() = articles.userid ) or ( note_type between 2 and 3 ) );

create policy "Users can insert their own articles."
  on articles for insert
  with check ( auth.uid() = articles.userid );

create policy "Users can update their own articles or free-updatable articles."
  on articles for update
  using ( ( auth.uid() = articles.userid ) or ( note_type = 3 ) );

create policy "Users can delete their own articles."
  on articles for delete
  using ( ( auth.uid() = articles.userid ) );

alter table articles add foreign key (userid) references profiles;

-- articles の誤更新防止
create table authors (
  id bigint not null,
  updated_at timestamp with time zone,
  userid uuid not null,

  primary key (id)
);

alter table authors enable row level security;

create policy "Authenticated Users can view all article-authors."
  on authors for select
  using ( auth.role() = 'authenticated' );

create policy "Users can insert their own article-authors."
  on authors for insert
  with check ( auth.uid() = authors.userid );

create policy "Users can delete their own article-authors."
  on authors for delete
  using ( ( auth.uid() = authors.userid ) );

alter table authors add foreign key (id) references articles;

alter policy "Users can update their own articles or free-updatable articles."
  on articles
  using ( (
            ( auth.uid() = articles.userid ) or ( articles.note_type = 3 )
          ) and
          ( articles.userid = (
            select userid from authors where articles.id = authors.id)
          )
        );

alter table articles
  add constraint note_type_range check (note_type between 1 and 3);

-- 秘密のプロフィール用 TCE key_id

select id from pgsodium.create_key(); -- ここで出た id を key_id の default へ転記

-- 秘密のプロフィール

create table privates (
  note_id bigint generated by default as identity,
  updated_at timestamp with time zone,
  secret_note text not null,
  key_id uuid not null default '【↑で出たid】'::uuid,
  nonce bytea default pgsodium.crypto_aead_det_noncegen(),
  userid uuid not null,

  primary key (note_id)
);

alter table privates enable row level security;

create policy "Users can view their own private profile."
  on privates for select
  using ( auth.uid() = userid );

create policy "Users can insert their own private profile."
  on privates for insert
  with check ( auth.uid() = userid );

create policy "Users can update their own private profile."
  on privates for update
  using ( auth.uid() = userid );

security label for pgsodium
  on column privates.secret_note
  is 'ENCRYPT WITH KEY COLUMN key_id ASSOCIATED (userid) NONCE nonce';

create view decrypted_privates as
  select note_id, userid, decrypted_secret_note
  from pgsodium_masks.privates
  where auth.uid() = userid
  order by userid asc, note_id desc
  limit 1;

grant select on pgsodium.valid_key to authenticated;
grant execute on all functions in schema pgsodium to authenticated;